!****d* Module/useful
! NAME
! useful
! SYNOPSIS
! use useful
! USES
! types, constants
! DESCRIPTION
! functions which are of general use
!
! Provides
!  cstr,error,get_unit
! AUTHOR
! Alin M. Elena (Queen's University Belfast)
! CREATION DATE
! 14-15th of January, 2006
!******

module useful
  use constants
  use types
  
  implicit none
  private
  public :: cstr,error,get_unit
  
contains

!****f*   useful/cstr()
! NAME
! cstr
! SYNOPSIS
! cstr()
! DESCRIPTION
! compares two strings not case sensitive returns true if the strings are the same false otherwise
! AUTHOR
! Alin M. Elena (Queen's University Belfast)
! CREATION DATE
! 14-15th of January, 2006
! HISTORY
!******

  logical function cstr(str1,str2)
    character(len=*), parameter :: myname = 'cstr'
    character(len=*) :: str1, str2
    integer :: len1,len2,i,s

    len1=len(str1)
    len2=len(str2)
    cstr=.false.
    if (len1==len2) then
      s=0
      do i=1,len1
        s=s+abs(up(str1(i:i))-up(str2(i:i)))
      enddo
      if (s==0) cstr=.true.
    endif

  contains
    integer function up(a)
      character(len=1) :: a
      if (iachar(a)>iachar("Z")) then
        up=iachar(a)-(iachar("a")-iachar("A"))
      else
        up=iachar(a)
      endif
    end function up
  end function cstr


!****s*   useful/error()
! NAME
! error
! SYNOPSIS
! call error(message, routine, critical,io_loc)
! INPUTS
!     character(len=*), intent(in) :: message
!     character(len=*), intent(in) :: routine
!     logical, intent(in)   :: critical
!     type(io_type), intent(in) :: io_loc
! DESCRIPTION
! Prints an error message (var message) submitted by a routine (var routine)
! using the units from io_loc.
! if critical is .true. will abort the program
! AUTHOR
! Alin M. Elena (Queen's University Belfast)
! CREATION DATE
! 14-15th January 2006, Alin M Elena (Queen's University Belfast)
! HISTORY
! 20th of January, 2007, by Alin M Elena (Queen's University Belfast), added io_loc parameter
!******


! provides an elegant way of handling different errors
  subroutine error(message, routine, critical,io_loc)
    character(len=*), intent(in) :: message
    character(len=*), intent(in) :: routine
    logical, intent(in)   :: critical
    type(io_type), intent(in) :: io_loc
    
    if (critical) then
      write(io_loc%uout,*) &
        "Critical error in subroutine: ", routine
    else
      write(io_loc%uout,*) &
        "Error message from subroutine: ", routine
    end if
    
    write(io_loc%uout,*) routine,": ", message
    
    if (critical) then
      write(io_loc%uout,*)routine,": User stop."
      write(*,*)routine," User stop."
      stop
    endif
    
  end subroutine error


!****f*   useful/get_unit()
! NAME
! get_unit
! SYNOPSIS
! get_unit()
! DESCRIPTION
! gives you an integer that you can use as unit to open a file assures that the integer was not previous generated by the function
! USES
! AUTHOR
! Alin M. Elena (Queen's University Belfast)
! CREATION DATE
! 14-15th of January, 2006
! HISTORY
!******


  integer function get_unit()
    character(len=*), parameter :: myname = 'get_unit()'
    integer,save ::ustart=9

    ustart=ustart+1
    get_unit=ustart

  end function get_unit

end module useful

